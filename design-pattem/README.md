# 设计模式 Samples:
## 1. [策略模式(算法簇模式)](src/main/java/cn/chenzw/design_pattem/strategy) :

**定义** :定义了不同的算法族（实现共同的接口），并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

策略模式中有3个对象：
- **环境对象**：该类中实现了对抽象策略中定义的接口或者抽象类的引用（持有一个Strategy的引用）
- **抽象策略对象**：它可由接口或抽象类来实现。
- **具体策略对象**：它封装了实现同不功能的不同算法。


## 2. [观察者模式](src/main/java/cn/chenzw/design_pattem/observer) :

**定义** :定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖都会收到通知并自动更新。

观察者模式有4个对象：
- **抽象主题（Subject）** : 主题的抽象接口, 定义了新增观察者、删除观察者和通知观察者方法。
- **具体主题（ConcreteSubject）** ：维护了一个观察者列表数据，当其状态发生改变时，它会将这个变化通知观察者。
- **抽象观察者（Observer）** : 定义了接收更新的方法。
- **具体观察者（ConcreteObserver）** ：实现接收方法，对接收到的数据进行更新。

## 2.1 [JDK提供的观察者模式](src/main/java/cn/chenzw/design_pattem/jdk_observer) :
通过继承java.util.Observable类来创建主题类，通过实现java.util.Observer接口来创建观察者类，此处值得注意的是，在调用Observable类的notifyObservers()或notifyObservers(Object)前，必须先调用setChanged()来标记状态已改变，否则不会通知观察者。

## 3. [装饰者模式](src/main/java/cn/chenzw/design_pattem/decorator) :

**定义** : 动态地将责任附加到对象上。

装饰者模式的设计原则为：对扩展开放、对修改关闭（想扩展被装饰者类的行为，无须修改装饰者抽象类，只需继承装饰者抽象类，实现额外的一些装饰或者叫行为即可对被装饰者进行包装。）

装饰者模式主要有4个对象： （一个被装饰者对应多个装饰者）
- **抽象被装饰者（Componenet）** ：定义了核心的业务方法
- **具体被装饰者（ConcreteComponent）** ：实现Component接口，实现具体核心的业务
- **抽象装饰者（Decorator）** ：实现Component接口，并使用策略模式，持有一个Component的引用。通常为虚类，避免被实例化。
- **具体装饰者（ConcreteDecorator）** ：继承Decorator类（此继承主要是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为），调用super的业务方法，并在此调用前后加上要装饰的业务逻辑。

## 4. [简单工厂模式|静态工厂模式](src/main/java/cn/chenzw/design_pattem/simple_factory) :

**定义** : 定义一个用于创建对象的接口。

简单工厂有3个角色：
- **工厂类角色（Factory）** ：这是本模式的核心，含有一定的商业逻辑和判断逻辑。往往由一个具体类实现。
- **抽象产品角色（Product）** ：产品的抽象类。由接口或者抽象类来实现。
- **具体产品角色（ConcreteProduct）** ：工厂类所创建的对象就是此角色的实例。

## 5. [工厂模式](src/main/java/cn/chenzw/design_pattem/factory) :

**定义** : 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

工厂模式有4个角色：
- **抽象工厂角色** ： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。由抽象类或者接口来实现。
- **具体工厂角色** ：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
- **抽象产品角色** ：产品的抽象类。一般由抽象类或者接口来实现。
- **具体产品角色** ：具体工厂角色所创建的对象就是此角色的实例。

## 6. [抽象工厂模式](src/main/java/cn/chenzw/design_pattem/absract_factory) :

**定义** : 提供了一个接口，用于创建一系列`相关或依赖`对象的家族（`产品族`），而不需要明确指定具体类。

## 7. [单例模式](src/main/java/cn/chenzw/design_pattem/singleton) :

单例模式主要有以下几种实现方式：
- **[恶汉模式](src/main/java/cn/chenzw/design_pattem/singleton/hungry)**
- **[懒汉模式](src/main/java/cn/chenzw/design_pattem/singleton/lazy)**
- **[懒汉模式-使用双重检查锁](src/main/java/cn/chenzw/design_pattem/singleton/hungry)**
- **[使用内部静态类](src/main/java/cn/chenzw/design_pattem/singleton/inner)**

## 8. [命令模式](src/main/java/cn/chenzw/design_pattem/command) :

**定义** ：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

命令模式有4个角色：
- **Command** ：定义命令的接口，声明执行的方法。
- **ConcreteCommand** ：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
- **Receiver** ：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
- **Invoker** ：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。

## 9. [适配器模式](src/main/java/cn/chenzw/design_pattem/adapter) :

**定义** : 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

适配器模式有3个角色：
- **目标接口（Target）** ：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
- **需要适配的类（Adaptee）** ：需要适配的类或适配者类。
- **适配器（Adapter）** ：通过包装一个需要适配的对象，把原接口转换成目标接口。

适配器分为`对象适配器`和`类适配器`,类适配器需要多继承，所以java中只能使用对象适配器。

## 10. [外观模式](src/main/java/cn/chenzw/design_pattem/facade) :

**定义** : 外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子接口更容易使用。

## 11. [模板方法模式](src/main/java/cn/chenzw/design_pattem/template) :

**定义** : 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。

模板方法模式有2个角色：
- **抽象模板(Abstract Template)** ：
■ 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
■ 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。
- **具体模板(Concrete Template)** ：
■ 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
■ 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。
